import "./chunk-MB5FDF5C.js";

// node_modules/@css-modules-theme/core/dist/core.es.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function filterThemeWithPrefix(theme, prefix) {
  var prefixLength = prefix.length;
  var result = {};
  for (var key in theme) {
    if (theme.hasOwnProperty(key) && key.indexOf(prefix) === 0) {
      result[key.substr(prefixLength)] = theme[key];
    }
  }
  return result;
}
function getThemeCompositionDependencies(theme) {
  var result = /* @__PURE__ */ Object.create(null);
  var dependenciesExist = false;
  for (var key in theme) {
    if (theme.hasOwnProperty(key)) {
      var search = " " + theme[key] + " ";
      for (var anotherKey in theme) {
        if (theme.hasOwnProperty(anotherKey) && anotherKey !== key && (theme[anotherKey] + " ").indexOf(search) !== -1) {
          if (result[key] === void 0) {
            dependenciesExist = true;
            result[key] = [anotherKey];
          } else {
            result[key].push(anotherKey);
          }
        }
      }
    }
  }
  if (dependenciesExist) {
    return result;
  }
  return void 0;
}
var Compose;
(function(Compose2) {
  Compose2["Merge"] = "merge";
  Compose2["Assign"] = "assign";
  Compose2["Replace"] = "replace";
})(Compose || (Compose = {}));
var composedThemesCacheMap = /* @__PURE__ */ new WeakMap();
var prefixedThemesCacheMap = /* @__PURE__ */ new WeakMap();
var dependenciesCacheMap = /* @__PURE__ */ new WeakMap();
var getCachedPrefixedTheme = function getCachedPrefixedTheme2(theme, prefix) {
  var ownPrefixedItems = prefixedThemesCacheMap.get(theme);
  var ownPrefixeditem;
  if (ownPrefixedItems === void 0) {
    ownPrefixedItems = [];
    prefixedThemesCacheMap.set(theme, ownPrefixedItems);
  } else {
    ownPrefixeditem = ownPrefixedItems.find(function(item) {
      return item.theme === theme && item.prefix === prefix;
    });
  }
  if (ownPrefixeditem === void 0) {
    ownPrefixeditem = {
      theme,
      prefix,
      finalTheme: filterThemeWithPrefix(theme, prefix)
    };
    ownPrefixedItems.push(ownPrefixeditem);
  }
  return ownPrefixeditem.finalTheme;
};
var getCachedThemeCompositionDependencies = function getCachedThemeCompositionDependencies2(theme) {
  var dependencies = dependenciesCacheMap.get(theme);
  if (dependencies === void 0) {
    dependencies = getThemeCompositionDependencies(theme);
    if (dependencies !== void 0) {
      dependenciesCacheMap.set(theme, dependencies);
    }
  }
  return dependencies;
};
var composeTheme = function composeTheme2(options) {
  var first = options[0];
  var checkCache = first.noCache !== true;
  var composeMethod = typeof first.compose === "string" ? first.compose : Compose.Merge;
  var resultTheme;
  var dependencies;
  if (typeof first.prefix === "string" && first.prefix.length > 0) {
    resultTheme = getCachedPrefixedTheme(first.theme, first.prefix);
  } else {
    resultTheme = first.theme;
  }
  var _loop = function _loop2(i2) {
    var _options$i = options[i2], theme = _options$i.theme, prefix = _options$i.prefix, compose = _options$i.compose, noParseComposes = _options$i.noParseComposes, _options$i$noCache = _options$i.noCache, noCache = _options$i$noCache === void 0 ? false : _options$i$noCache;
    var parseComposes = typeof noParseComposes === "boolean" ? noParseComposes === false : first.noParseComposes !== true;
    if (typeof compose === "string") {
      composeMethod = compose;
    }
    if (noCache && checkCache) {
      checkCache = false;
    }
    var composedCachedItem = void 0;
    if (checkCache && composeMethod !== Compose.Replace) {
      var composedThemesCache = composedThemesCacheMap.get(theme);
      if (composedThemesCache === void 0) {
        composedThemesCache = [];
        composedThemesCacheMap.set(theme, composedThemesCache);
      } else {
        composedCachedItem = composedThemesCache.find(function(item) {
          return item.againstTheme === resultTheme && item.prefix === prefix && item.composeMethod === composeMethod && item.parseComposes === parseComposes;
        });
        if (composedCachedItem !== void 0) {
          resultTheme = composedCachedItem.composedTheme;
          return "continue";
        }
      }
      composedCachedItem = {
        againstTheme: resultTheme,
        prefix,
        composeMethod,
        parseComposes
      };
      composedThemesCache.push(composedCachedItem);
    }
    var composedTheme = void 0;
    if (typeof prefix === "string" && prefix.length > 0) {
      composedTheme = (noCache ? filterThemeWithPrefix : getCachedPrefixedTheme)(theme, prefix);
    } else {
      composedTheme = theme;
    }
    if (composeMethod === Compose.Replace) {
      resultTheme = composedTheme;
      if (parseComposes && i2 < options.length - 1) {
        dependencies = checkCache ? getCachedThemeCompositionDependencies(resultTheme) : getThemeCompositionDependencies(resultTheme);
      }
      return "continue";
    }
    if (i2 === 1 && noParseComposes !== true) {
      dependencies = checkCache ? getCachedThemeCompositionDependencies(first.theme) : getThemeCompositionDependencies(first.theme);
    }
    if (composeMethod === Compose.Merge) {
      var composedThemeOriginal = composedTheme;
      composedTheme = _extends({}, resultTheme);
      for (var key in composedThemeOriginal) {
        if (composedThemeOriginal.hasOwnProperty(key)) {
          var targetClasses = composedTheme[key];
          var composingClasses = composedThemeOriginal[key];
          if (targetClasses !== void 0) {
            composingClasses = targetClasses + " " + composingClasses;
            if (parseComposes === true && dependencies !== void 0 && dependencies[key] !== void 0) {
              var targetClassRegex = new RegExp("\\b" + targetClasses + "\\b");
              for (var _iterator = dependencies[key], _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
                var _ref;
                if (_isArray) {
                  if (_i >= _iterator.length)
                    break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done)
                    break;
                  _ref = _i.value;
                }
                var otherKey = _ref;
                composedTheme[otherKey] = composedTheme[otherKey].replace(targetClassRegex, composingClasses);
              }
            }
          }
          composedTheme[key] = composingClasses;
        }
      }
    } else if (composeMethod === Compose.Assign) {
      if (dependencies === void 0 || parseComposes === false) {
        composedTheme = _extends({}, resultTheme, {}, composedTheme);
      } else {
        var _composedThemeOriginal = composedTheme;
        composedTheme = _extends({}, resultTheme);
        for (var _key in _composedThemeOriginal) {
          if (_composedThemeOriginal.hasOwnProperty(_key)) {
            var _targetClasses = composedTheme[_key];
            var _composingClasses = _composedThemeOriginal[_key];
            if (dependencies[_key] !== void 0) {
              var _targetClassRegex = new RegExp("\\b" + _targetClasses + "\\b");
              for (var _iterator2 = dependencies[_key], _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
                var _ref2;
                if (_isArray2) {
                  if (_i2 >= _iterator2.length)
                    break;
                  _ref2 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done)
                    break;
                  _ref2 = _i2.value;
                }
                var _otherKey = _ref2;
                composedTheme[_otherKey] = composedTheme[_otherKey].replace(_targetClassRegex, _composingClasses);
              }
            }
            composedTheme[_key] = _composingClasses;
          }
        }
      }
    }
    if (composedCachedItem !== void 0) {
      composedCachedItem.composedTheme = composedTheme;
    }
    resultTheme = composedTheme;
  };
  for (var i = 1; i < options.length; i++) {
    var _ret = _loop(i);
    if (_ret === "continue")
      continue;
  }
  return resultTheme;
};
export {
  Compose,
  composeTheme,
  filterThemeWithPrefix,
  getCachedPrefixedTheme,
  getCachedThemeCompositionDependencies,
  getThemeCompositionDependencies
};
//# sourceMappingURL=@css-modules-theme_core.js.map
