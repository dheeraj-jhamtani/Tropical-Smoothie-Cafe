import YextRtfConverter from '../src/converter';
import { nestedListsTestCase } from './fixtures';

const yextRtfConverter = new YextRtfConverter();
const convertToHTML =
  markdown => yextRtfConverter.toHTML(markdown);

describe('supports various elements', () => {
  it('works with images', () => {
    const richText = '![foo](/www.example.com)';
    const html = convertToHTML(richText);
    const expectedResult = '<p><img src=\"/www.example.com\" alt=\"foo\"></p>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with images and a title', () => {
    const richText = '![foo](/www.example.com "Foobar")';
    const html = convertToHTML(richText);
    const expectedResult = '<p><img src="/www.example.com" alt="foo" title="Foobar"></p>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with code spans', () => {
    const richText = '`foo`';
    const html = convertToHTML(richText);
    const expectedResult = '<p><code>foo</code></p>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with code blocks defined with a backtick fence', () => {
    const richText =
      '```\n' +
      'foo\n' +
      'bar\n' +
      '```\n';
    const html = convertToHTML(richText);
    const expectedResult = '<pre><code>foo\nbar\n</code></pre>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with code blocks defined with a tilde fence', () => {
    const richText =
      '~~~\n' +
      'foo\n' +
      'bar\n' +
      '~~~\n';
    const html = convertToHTML(richText);
    const expectedResult = '<pre><code>foo\nbar\n</code></pre>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with block quotes', () => {
    const richText = '> foo';
    const html = convertToHTML(richText);
    const expectedResult =
      '<blockquote>\n' +
      '<p>foo</p>\n' +
      '</blockquote>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with horizontal lines defined with dashes', () => {
    const richText = '---';
    const html = convertToHTML(richText);
    const expectedResult = '<hr>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with horizontal lines defined with underlines', () => {
    const richText = '___';
    const html = convertToHTML(richText);
    const expectedResult = '<hr>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with horizontal lines defined with asterisks', () => {
    const richText = '***';
    const html = convertToHTML(richText);
    const expectedResult = '<hr>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with strikethrough', () => {
    const richText = '~~foo~~';
    const html = convertToHTML(richText);
    const expectedResult = '<p><s>foo</s></p>\n'
    expect(html).toEqual(expectedResult);
  });

  it('works with subscript', () => {
    const richText = '~subscript~';
    const html = convertToHTML(richText);
    const expectedResult = '<p><sub>subscript</sub></p>\n';
    expect(html).toEqual(expectedResult);
  });

  it('subscript cannot have spaces', () => {
    const richText = '~foo bar baz~';
    const html = convertToHTML(richText);
    const expectedResult = '<p>~foo bar baz~</p>\n';
    expect(html).toEqual(expectedResult);
  });

  it('works with superscript', () => {
    const richText = '^superscript^';
    const html = convertToHTML(richText);
    const expectedResult = '<p><sup>superscript</sup></p>\n';
    expect(html).toEqual(expectedResult);
  });

  it('works with code fences', () => {
    const richText = '```\n{ "this is": "a code fence" }\n```';
    const html = convertToHTML(richText);
    const expectedResult = '<pre><code>{ &quot;this is&quot;: &quot;a code fence&quot; }\n</code></pre>\n';
    expect(html).toEqual(expectedResult);
  });

  it('works with tables', () => {
    const richText = `
| Syntax      | Description |
| ----------- | ----------- |
| Header      | Title       |
| Paragraph   | Text        |
    `;
    const html = convertToHTML(richText);
    const expectedResult =
      `<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody>
</table>\n`;
    expect(html).toEqual(expectedResult);
  });
});

describe('works with headings', () => {
  const expectedConversions = {
    h1: {
      richText: '# foo',
      expectedHTML: '<h1>foo</h1>\n'
    },
    h2: {
      richText: '## foo',
      expectedHTML: '<h2>foo</h2>\n'
    },
    h3: {
      richText: '### foo',
      expectedHTML: '<h3>foo</h3>\n'
    },
    h4: {
      richText: '#### foo',
      expectedHTML: '<h4>foo</h4>\n'
    },
    h5: {
      richText: '##### foo',
      expectedHTML: '<h5>foo</h5>\n'
    },
    h6: {
      richText: '###### foo',
      expectedHTML: '<h6>foo</h6>\n'
    },
    h1_set_text: {
      richText:
        'foo\n' +
        '=====\n',
      expectedHTML: '<h1>foo</h1>\n'
    },
    h2_set_text: {
      richText:
        'foo\n' +
        '-------\n',
      expectedHTML: '<h2>foo</h2>\n'
    }
  };

  Object.entries(expectedConversions).forEach(([headingType, conversion]) => {
    it(`works with ${headingType} headings`, () => {
      const actualHTML = convertToHTML(conversion.richText);
      expect(actualHTML).toEqual(conversion.expectedHTML);
    });
  });
});

describe('formatting markdown with underlines in it', () => {
  it('works for the trival case', () => {
    const richText = '++I should be underlined++';
    const html = convertToHTML(richText);
    expect(html).toEqual('<p><u>I should be underlined</u></p>\n');
  });

  it('works when combined with italics', () => {
    const richText = '*++I should be underlined++*';
    const html = convertToHTML(richText);
    expect(html).toEqual('<p><em><u>I should be underlined</u></em></p>\n');
  });

  it('works when combined with bold', () => {
    const richText = '**++I should be underlined++**';
    const html = convertToHTML(richText);
    expect(html).toEqual('<p><strong><u>I should be underlined</u></strong></p>\n');
  });

  it('works when combined with strikethrough', () => {
    const richText = '~~++This was mistaken, underlined text++~~';
    const html = convertToHTML(richText);
    expect(html).toEqual('<p><s><u>This was mistaken, underlined text</u></s></p>\n');
  });

  it('works when combined with bold AND italics', () => {
    const richText = '***++I should be underlined++***';
    const html = convertToHTML(richText);
    expect(html).toEqual('<p><em><strong><u>I should be underlined</u></strong></em></p>\n');
  });

  it('works when combined with bold AND italics AND extra junk at the edges', () => {
    const richText = '**random stuff** __dont mind me__ ***++I should be \nunderlined++*** hope your tests pass! \n\n';
    const html = convertToHTML(richText);
    expect(html).toEqual('<p><strong>random stuff</strong> <strong>dont mind me</strong> <em><strong><u>I should be\nunderlined</u></strong></em> hope your tests pass!</p>\n');
  });

  it('works when there are multiple underlines', () => {
    const richText = '**++i am underlined++ ++i am also++** ++same++';
    const html = convertToHTML(richText);
    expect(html).toEqual('<p><strong><u>i am underlined</u> <u>i am also</u></strong> <u>same</u></p>\n');
  });

  it('works with code blocks', () => {
    const richText = '\tcode**code**++code++\n';
    const html = convertToHTML(richText);
    expect(html).toEqual('<pre><code>code**code**++code++\n</code></pre>\n');
  });

  it('works with multiple lists and links', () => {
    const richText =
      '**I AM BOLD** now I am not *I AM ITALICS* now I am not ++BRASAAAAAP++\n\n' +
      '* ++I am underline list++\n\n' +
      '1. ++I am number list++\n' +
      '2. ++[I am link to site](http://olivershi.io)++\n\n' +
      '++[url link](http://google.com)++\n\n' +
      '++[phone link](tel:+17326183404)++\n\n' +
      '++[email link](mailto:oshi@yext.com)++\n';

    const html = convertToHTML(richText);
    const expectedResult =
      '<p><strong>I AM BOLD</strong> now I am not <em>I AM ITALICS</em> now I am not <u>BRASAAAAAP</u></p>\n' +
      '<ul>\n' +
      '<li><u>I am underline list</u></li>\n' +
      '</ul>\n' +
      '<ol>\n' +
      '<li><u>I am number list</u></li>\n' +
      '<li><u><a href="http://olivershi.io">I am link to site</a></u></li>\n' +
      '</ol>\n' +
      '<p><u><a href="http://google.com">url link</a></u></p>\n' +
      '<p><u><a href="tel:+17326183404">phone link</a></u></p>\n' +
      '<p><u><a href="mailto:oshi@yext.com">email link</a></u></p>\n';
    expect(html).toEqual(expectedResult);
  });
});

describe('registers plugins correctly', () => {
  it('adds a new plugin correctly', () => {
    const testPlugin = (md, tag) => {
      function scan(state) {
        for (let token of state.tokens) {
          const tokenType = token.type;
          if (tokenType === 'paragraph_close' || tokenType === 'paragraph_open') {
            token.tag = tag;
          }
        }
      }
      md.core.ruler.push('test-plugin', scan);
    }
    yextRtfConverter.addPlugin(testPlugin, 'div');

    const expectedResult = '<div><u>Some Text</u></div>\n';
    const html = convertToHTML('++Some Text++');
    expect(html).toEqual(expectedResult);
  });

  it('removes plugin correctly', () => {
    yextRtfConverter.disablePlugin('test-plugin');

    const expectedResult = '<p><u>Some Text</u></p>\n';
    const html = convertToHTML('++Some Text++');
    expect(html).toEqual(expectedResult);
  });
});

it('works with nested lists', () => {
  const richText = nestedListsTestCase;
  const html = convertToHTML(richText);
  const expectedResult =
    `<ol>
<li>one
<ul>
<li>two
<ol>
<li>three
<ul>
<li>four <code>code</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>\n`;
  expect(html).toEqual(expectedResult);
});

it('works with escaped characters', () => {
  const richText = '\\* Without the backslash, this would be a bullet in an unordered list.';
  const expectedResult = '<p>* Without the backslash, this would be a bullet in an unordered list.</p>\n';
  const html = yextRtfConverter.toHTML(richText);
  expect(html).toEqual(expectedResult);
});
