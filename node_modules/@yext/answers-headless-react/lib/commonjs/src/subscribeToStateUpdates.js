"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToStateUpdates = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
// TODO(SLAP-1485): find out how to specify generic component props without using `any`
// I sank a 3-4 hours into this but couldn't figure out exactly how to get it to work.
// May require use of typescript generics.
/* eslint-disable @typescript-eslint/no-explicit-any */
const react_1 = require("react");
const AnswersHeadlessContext_1 = require("./AnswersHeadlessContext");
const isShallowEqual_1 = __importDefault(require("./utils/isShallowEqual"));
/**
 * Generates a HOC that updates a given Component's props based on the current
 * answers-headless state and a given mapping function.
 */
function subscribeToStateUpdates(mapStateToProps) {
    const generateSubscriberHOC = WrappedComponent => {
        /**
         * Keep manual track of the props mapped from state instead of storing
         * it in the AnswersHeadlessSubscriber's state. This avoids react's batching
         * of state updates, which can result in mappedState not updating immediately.
         * This can, in turn, result in extra answers-headless listener invocations.
         */
        let previousPropsFromState = {};
        return function AnswersHeadlessSubscriber(props) {
            const answers = (0, react_1.useContext)(AnswersHeadlessContext_1.AnswersHeadlessContext);
            const [mergedProps, dispatch] = (0, react_1.useReducer)(() => {
                return Object.assign(Object.assign({}, props), previousPropsFromState);
            }, Object.assign(Object.assign({}, props), mapStateToProps(answers.state)));
            (0, react_1.useEffect)(() => {
                return answers.addListener({
                    valueAccessor: (state) => mapStateToProps(state),
                    callback: newPropsFromState => {
                        if (!(0, isShallowEqual_1.default)(previousPropsFromState, newPropsFromState)) {
                            previousPropsFromState = newPropsFromState;
                            dispatch();
                        }
                    }
                });
            });
            return (0, jsx_runtime_1.jsx)(WrappedComponent, Object.assign({}, mergedProps), void 0);
        };
    };
    return generateSubscriberHOC;
}
exports.subscribeToStateUpdates = subscribeToStateUpdates;
//# sourceMappingURL=subscribeToStateUpdates.js.map