import { Unsubscribe } from '@reduxjs/toolkit';

/**
 * AdditionalHttpHeaders allows users to specify additional values for specific HTTP headers.
 *
 * @public
 **/
export declare interface AdditionalHttpHeaders {
    /** {@inheritDoc ClientSDKHeaderValues} */
    'Client-SDK'?: ClientSDKHeaderValues;
}

/**
 * Represents all results for the current vertical.
 *
 * @public
 */
export declare interface AllResultsForVertical {
    /**
     * {@inheritDoc FiltersState.facets}
     */
    facets: DisplayableFacet[];
    /**
     * The array of all results for the vertical.
     */
    results: Result[];
    /**
     * The total number of results for the vertical.
     */
    resultsCount: number;
}

/**
 * The main configuration options for {@link AnswersCore}.
 * For a full description of the options, see {@link BaseAnswersConfig}.
 * The config requires either an apiKey or a token.
 *
 * @public
 */
export declare type AnswersConfig = AnswersConfigWithApiKey | AnswersConfigWithToken;

/**
 * Configuration options for {@link AnswersCore}, which includes the
 * options from {@link BaseAnswersConfig}, but requires apiKey.
 * @public
 */
export declare interface AnswersConfigWithApiKey extends BaseAnswersConfig {
    /** The api key of the answers experience which will be sent as a query param. */
    apiKey: string;
    /**
     * token should NOT be provided along with apiKey.
     */
    token?: never;
}

/**
 * Configuration options for {@link AnswersCore}, which includes the
 * options from {@link BaseAnswersConfig}, but requires token.
 * @public
 */
export declare interface AnswersConfigWithToken extends BaseAnswersConfig {
    /**
     * The authentication token of the answers experience
     * which will be passed in the Auth header as a Bearer token.
     */
    token: string;
    /**
     * apiKey should NOT be provided along with token.
     */
    apiKey?: never;
}

/**
 * Provides methods for executing searches, submitting questions, and performing autocompletes.
 *
 * @public
 */
export declare class AnswersCore {
    private searchService;
    private questionSubmissionService;
    private autoCompleteService;
    constructor(searchService: SearchService, questionSubmissionService: QuestionSubmissionService, autoCompleteService: AutocompleteService);
    /**
     * Performs an Answers search across all verticals.
     *
     * @remarks
     * If rejected, the reason will be an {@link AnswersError}.
     *
     * @param request - Universal search request options
     */
    universalSearch(request: UniversalSearchRequest): Promise<UniversalSearchResponse>;
    /**
     * Performs an Answers search for a single vertical.
     *
     * @remarks
     * If rejected, the reason will be an {@link AnswersError}.
     *
     * @param request - Vertical search request options
     */
    verticalSearch(request: VerticalSearchRequest): Promise<VerticalSearchResponse>;
    /**
     * Submits a custom question to the Answers API.
     *
     * @remarks
     * If rejected, the reason will be an {@link AnswersError}.
     *
     * @param request - Question submission request options
     */
    submitQuestion(request: QuestionSubmissionRequest): Promise<QuestionSubmissionResponse>;
    /**
     * Performs an autocomplete request across all verticals.
     *
     * @remarks
     * If rejected, the reason will be an {@link AnswersError}.
     *
     * @param request - Universal autocomplete request options
     */
    universalAutocomplete(request: UniversalAutocompleteRequest): Promise<AutocompleteResponse>;
    /**
     * Performs an autocomplete request for a single vertical.
     *
     * @remarks
     * If rejected, the reason will be an {@link AnswersError}.
     *
     * @param request - Vertical autocomplete request options
     */
    verticalAutocomplete(request: VerticalAutocompleteRequest): Promise<AutocompleteResponse>;
    /**
     * Performs a filtersearch request against specified fields within a single vertical.
     *
     * @remarks
     * This differs from the vertical autocomplete because the vertical autocomplete
     * operates on all entity fields whereas filtersearch operates only on specified fields.
     * If rejected, the reason will be an {@link AnswersError}.
     *
     * @example
     * A site has a 'products' vertical and would like a way to allow the user to narrow down
     * the results by the product name. The site can add a second search bar powered by filtersearch
     * which will include only product names as search suggestions.
     *
     * @param request - filtersearch request options
     */
    filterSearch(request: FilterSearchRequest): Promise<FilterSearchResponse>;
}

/**
 * Represents an error
 *
 * @remarks
 * If the error originates from the Answer API, the code and type property will be present.
 *
 * @public
 */
export declare class AnswersError extends Error {
    /** The error message. */
    message: string;
    /** Answers API error code. */
    code?: number;
    /** Answers API error type. */
    type?: string;
    /* Excluded from this release type: __constructor */
}

/**
 * Provides the functionality for interacting with an Answers Search experience.
 *
 * @public
 */
export declare class AnswersHeadless {
    private core;
    private stateManager;
    private httpManager;
    private additionalHttpHeaders?;
    /**
     * Common utility functions for manipulating Answers-related data.
     */
    readonly utilities: typeof answersUtilities;
    constructor(core: AnswersCore, stateManager: StateManager, httpManager: HttpManager, additionalHttpHeaders?: AdditionalHttpHeaders | undefined);
    /**
     * Sets {@link QueryState.input} to the specified input.
     *
     * @param input - The input to set
     */
    setQuery(input: string): void;
    /**
     * Sets {@link QueryState.queryTrigger} to the specified trigger.
     *
     * @param trigger - The query trigger to set
     */
    setQueryTrigger(trigger: QueryTrigger): void;
    /**
     * Sets {@link QueryState.querySource} to the specified source.
     *
     * @param source - The query source to set
     */
    setQuerySource(source: QuerySource): void;
    /**
     * Sets up Headless to manage the vertical indicated by the verticalKey.
     *
     * @param verticalKey - The vertical key to set
     */
    setVertical(verticalKey: string): void;
    /**
     * Sets up Headless to manage universal searches.
     */
    setUniversal(): void;
    /**
     * Resets the direct answer, filters, query rules, search status, vertical, and universal states
     * to their initial values.
     */
    private _resetSearcherStates;
    /**
     * Sets {@link VerticalSearchState.limit} to the specified limit.
     *
     * @param limit - The vertical limit to set
     */
    setVerticalLimit(limit: number): void;
    /**
     * Sets {@link UniversalSearchState.limit} to the specified limit.
     *
     * @param limit - The universal limit to set
     */
    setUniversalLimit(limit: UniversalLimit): void;
    /**
     * Sets {@link VerticalSearchState.offset} to the specified offset.
     *
     * @param offset - The vertical offset to set
     */
    setOffset(offset: number): void;
    /**
     * Sets {@link FiltersState."static"} to the specified filters.
     *
     * @param filters - The static filters to set
     */
    setStaticFilters(filters: SelectableFilter[]): void;
    /**
     * Sets {@link FiltersState.facets} to the specified facets.
     *
     * @param facets - The facets to set
     */
    setFacets(facets: DisplayableFacet[]): void;
    /**
     * Unselects all {@link FiltersState.facets | facets}.
     */
    resetFacets(): void;
    /**
     * Sets {@link SpellCheckState.enabled} to the specified boolean value.
     *
     * @param enabled - Whether or not spellcheck should be set to enabled
     */
    setSpellCheckEnabled(enabled: boolean): void;
    /**
     * Sets {@link SessionTrackingState.enabled} to the specified boolean value.
     *
     * @param enabled - Whether or not session tracking should be set to enabled
     */
    setSessionTrackingEnabled(enabled: boolean): void;
    /**
     * Sets {@link SessionTrackingState.sessionId} to the specified ID.
     *
     * @param sessionId - The session ID to set
     */
    setSessionId(sessionId: string): void;
    /**
     * Sets the alternativeVerticals for {@link VerticalSearchState.noResults} to the
     * specified verticals.
     *
     * @param alternativeVerticals - The alternative verticals to set
     */
    setAlternativeVerticals(alternativeVerticals: VerticalResults[]): void;
    /**
     * Sets {@link VerticalSearchState.sortBys} to the specified sortBys.
     *
     * @param sortBys - The sortBys to set
     */
    setSortBys(sortBys: SortBy[]): void;
    /**
     * Sets {@link MetaState.context} to the specified context.
     *
     * @param context - The context to set
     */
    setContext(context: Context): void;
    /**
     * Sets {@link MetaState.referrerPageUrl} to the specified URL.
     *
     * @param referrerPageUrl - The referring page URL to set
     */
    setReferrerPageUrl(referrerPageUrl: string): void;
    /**
     * Sets {@link LocationState.userLocation} to the specified latitude and
     * longitude.
     *
     * @param latLong - The user location to set
     */
    setUserLocation(latLong: LatLong): void;
    /**
     * Sets the {@link State} to the specified state.
     *
     * @param state - The state to set
     */
    setState(state: State): void;
    /**
     * Sets {@link UniversalSearchState.restrictVerticals} to the specified vertical
     * keys.
     *
     * @param restrictVerticals - The new verticals to restrict a universal search
     */
    setRestrictVerticals(restrictVerticals: string[]): void;
    /**
     * Gets the current state of the AnswersHeadless instance.
     */
    get state(): State;
    /**
     * Adds a listener for a specific state value of type T.
     *
     * @param listener - The listener to add
     * @returns The function for removing the added listener
     */
    addListener<T>(listener: StateListener<T>): Unsubscribe;
    /**
     * Submits a question to the Answers API with the specified request data.
     *
     * @param request - The data for the network request
     * @returns A Promise of a {@link QuestionSubmissionResponse} from the Answers API
     */
    submitQuestion(request: Omit<QuestionSubmissionRequest, 'additionalHttpHeaders'>): Promise<QuestionSubmissionResponse>;
    /**
     * Performs an Answers search across all verticals with relevant parts of the
     * state used as input to the search. Updates the state with the response data.
     *
     * @returns A Promise of a {@link UniversalSearchResponse} from the Answers API
     */
    executeUniversalQuery(): Promise<UniversalSearchResponse | undefined>;
    /**
     * Performs an autocomplete request across all verticals using the query input
     * stored in state.
     *
     * @returns A Promise of an {@link AutocompleteResponse} from the Answers API
     */
    executeUniversalAutocomplete(): Promise<AutocompleteResponse>;
    /**
     * Perform an Answers search for a single vertical with relevant parts of the
     * state used as input to the search. Updates the state with the response data.
     *
     * @returns A Promise of a {@link VerticalSearchResponse} from the Answers API or
     *          of undefined if there is no verticalKey defined in state
     */
    executeVerticalQuery(): Promise<VerticalSearchResponse | undefined>;
    /**
     * Performs an autocomplete request for a single vertical using the query input
     * and vertical key stored in state.
     *
     * @returns A Promise of an {@link AutocompleteResponse} from the Answers API or
     *          of undefined if there is no verticalKey defined in state
     */
    executeVerticalAutocomplete(): Promise<AutocompleteResponse | undefined>;
    /**
     * Performs a filtersearch request against specified fields within a single
     * vertical using the vertical key stored in state.
     *
     * @param query - The query for which to search
     * @param sectioned - Whether or not the results should be sectioned by field
     * @param fields - The entity fields to search
     * @returns A Promise of a {@link FilterSearchResponse} from the Answers API or
     *          of undefined if there is no verticalKey defined in state
     */
    executeFilterSearch(query: string, sectioned: boolean, fields: SearchParameterField[]): Promise<FilterSearchResponse | undefined>;
    /**
     * Sets a specified facet option to be selected or unselected.
     *
     * @param fieldId - The fieldId for the facet
     * @param facetOption - The option of the facet to select
     * @param selected - Whether or not the facet option should be selected
     */
    setFacetOption(fieldId: string, facetOption: FacetOption, selected: boolean): void;
    /**
     * Sets a static filter option and whether or not it is selected in state.
     *
     * @param filter - The static filter and whether it is selected
     */
    setFilterOption(filter: SelectableFilter): void;
}

/**
 * Options for an Answers API request.
 *
 * @public
 */
export declare interface AnswersRequest {
    /** {@inheritDoc AdditionalHttpHeaders} */
    additionalHttpHeaders?: AdditionalHttpHeaders;
}

declare namespace answersUtilities {
    export {
        searchThroughFacet,
        isCloseMatch
    }
}
export { answersUtilities }

/**
 * A filter that the Answers API applied to the search.
 *
 * @public
 */
export declare interface AppliedQueryFilter {
    /**
     * The display name of the filter key.
     *
     * @example
     * 'Job Category'
     */
    displayKey: string;
    /**
     * The value used in the filter.
     *
     * @example
     * 'Sales'
     */
    displayValue: string;
    /** The filter applied to the query results. */
    filter: Filter;
    /** {@inheritDoc AppliedQueryFilterType} */
    type: AppliedQueryFilterType;
    /** {@inheritDoc LocationFilterDetails} */
    details?: LocationFilterDetails;
}

/**
 * Represents the type of {@link AppliedQueryFilter} applied to a search.
 *
 * @public
 */
export declare enum AppliedQueryFilterType {
    /** Indicates that a field value filter is applied based on the query. */
    FieldValue = "FIELD_VALUE",
    /** Indicates that a location filter is applied based on the query. */
    Place = "PLACE",
    /** Indicates that a search intent filter is applied based on the query. */
    Intent = "INTENT"
}

/**
 * The response of a universal or vertical autocomplete request.
 *
 * @public
 */
export declare interface AutocompleteResponse {
    /** An array of {@link AutocompleteResult}s. */
    results: AutocompleteResult[];
    /** {@inheritDoc SearchIntent} */
    inputIntents: SearchIntent[];
    /** The ID of the search query. */
    queryId?: string;
    /** A unique id which corresponds to the request. */
    uuid: string;
}

/**
 * An autocomplete suggestion.
 *
 * @public
 */
export declare interface AutocompleteResult {
    /** The value of an autocomplete suggestion. */
    value: string;
    /**
     * A filter applied to the autocomplete response.
     *
     * @remarks
     * This property is only defined for filtersearch.
     */
    filter?: Filter;
    /**
     * The fieldId which corresponds to the AutocompleteResult value.
     *
     * @remarks
     * This property is only defined for filtersearch.
     */
    key?: string;
    /**
     * An array of substrings which overlap with the autocomplete input.
     *
     * @remarks
     * Offset indicates the index of the match, and the length indicates the number of characters of the match.
     */
    matchedSubstrings?: {
        length: number;
        offset: number;
    }[];
    /**
     * An entity that corresponds to the autocomplete result.
     *
     * @remarks
     * This property is only defined if the corresponding
     * {@link SearchParameterField.fetchEntities} field is true.
     */
    relatedItem?: Result;
    /**
     * Any vertical keys associated with a prompt.
     * This only shows up on universal autocomplete requests.
     **/
    verticalKeys?: string[];
}

/**
 * A service for autocomplete requests.
 *
 * @public
 */
export declare interface AutocompleteService {
    /**
     * Retrieves query suggestions for universal.
     */
    universalAutocomplete(request: UniversalAutocompleteRequest): Promise<AutocompleteResponse>;
    /**
     * Retrieves query suggestions for a vertical.
     */
    verticalAutocomplete(request: VerticalAutocompleteRequest): Promise<AutocompleteResponse>;
    /**
     * Retrieves query suggestions for filter search.
     */
    filterSearch(request: FilterSearchRequest): Promise<FilterSearchResponse>;
}

/**
 * The base configuration options for {@link AnswersCore}.
 * @public
 */
export declare interface BaseAnswersConfig {
    /** The experience key of the answers experience. */
    experienceKey: string;
    /** The locale of the answers experience. */
    locale: string;
    /**
     * The version of the answers experience configuration.
     *
     * @remarks
     * May be a configuration label (string) or a configuration version (number).
     *
     * @example
     * Examples: 'PRODUCTION', 42
     */
    experienceVersion?: 'STAGING' | 'PRODUCTION' | string | number;
    /** {@inheritDoc Visitor} */
    visitor?: Visitor;
    /**
     * {@inheritDoc Endpoints}
     *
     * @public
     */
    endpoints?: Endpoints;
    /* Excluded from this release type: additionalQueryParams */
}

/**
 * An interface representing a range of values of type T.
 *
 * @public
 */
export declare interface BoundedRange<T> {
    /**
     * The minimum value bounding the range.
     */
    min?: RangeBoundary<T>;
    /**
     * The maximum value bounding the range.
     */
    max?: RangeBoundary<T>;
}

/**
 * Additional agents and their versions used to create the Answers experience. The information for these
 * agents is added to the Client-SDK HTTP header along with that of the ANSWERS_CORE agent.
 *
 * @public
 */
export declare interface ClientSDKHeaderValues {
    /** A mapping of the additional agents that are part of the Client-SDK to their versions. */
    [agent: string]: string | undefined;
    /**
     * The ANSWERS_CORE agent should not be supplied. Instead, it will be automatically added to the
     * header and populated with the version of Answers Core being used.
     */
    ANSWERS_CORE?: never;
}

/**
 * Represents multiple filters that will be combined to refine results.
 *
 * @public
 */
export declare interface CombinedFilter {
    /** An array of filters applied to the search. */
    filters: (Filter | CombinedFilter)[];
    /** The logical operator used to combine the filters. */
    combinator: FilterCombinator;
}

/**
 * Creates a {@link CombinedFilter} by applying the specified {@link FilterCombinator}
 * to the two filters.
 *
 * @param filterA - The first filter to be combined
 * @param filterB - The second filter to be combined
 * @param combinator - Specifies how the two filters should be joined
 * @returns The newly created {@link CombinedFilter}
 *
 * @public
 */
export declare function combineFilters(filterA: FilterTypes, filterB: FilterTypes, combinator: FilterCombinator): CombinedFilter;

/**
 * Used to trigger Answers
 * {@link https://hitchhikers.yext.com/tracks/answers-advanced/ans302-query-rules/ | Query Rules}.
 *
 * @remarks
 * May be any valid JSON object
 *
 * @public
 */
export declare type Context = any;

/**
 * Creates a {@link Filter} or {@link CombinedFilter} that matches all results where the
 * given field value falls in a specific Date {@link BoundedRange}.
 *
 * @param fieldId - The comparison field's identifier
 * @param range - The acceptable date range
 * @returns The newly created filter for the field value range
 *
 * @public
 */
export declare function createDateRangeFilter(fieldId: string, range: BoundedRange<Date>): FilterTypes;

/**
 * Creates a simple {@link Filter} that ensures all results will match a specific
 * field value.
 *
 * @param fieldId - The comparison field's identifier
 * @param value - The value to match
 * @returns The newly created {@link Filter} for the field value
 *
 * @public
 */
export declare function createEqualsFilter(fieldId: string, value: string | number | boolean): Filter;

/**
 * Creates a {@link Filter} that matches all results within a certain radius of the
 * given position.
 *
 * @param position - The position and radius
 * @returns The newly created {@link Filter} for the radius of the position
 *
 * @public
 */
export declare function createNearMeFilter(position: NearFilterValue): Filter;

/**
 * Creates a {@link Filter} or {@link CombinedFilter} that matches all results where the
 * given field value falls in a specific number {@link BoundedRange}.
 *
 * @param fieldId - The comparison field's identifier
 * @param range - The acceptable number range
 * @returns The newly created filter for the field value range
 *
 * @public
 */
export declare function createNumberRangeFilter(fieldId: string, range: BoundedRange<number>): FilterTypes;

/**
 * The headlessId automatically given to the first AnswersHeadless instance created.
 *
 * @public
 */
export declare const DEFAULT_HEADLESS_ID = "main";

/**
 * A direct answer to a search.
 *
 * @public
 */
export declare interface DirectAnswer {
    /** The {@link DirectAnswerType}. */
    type: DirectAnswerType;
    /**
     * The result of the direct answer.
     *
     * @remarks
     * A value will not be present if the {@link DirectAnswer.fieldType} is 'rich_text'.
     */
    value?: string;
    /** The entity associated with the direct answer. */
    relatedResult: Result;
    /** The vertical key of the direct answer. */
    verticalKey: string;
    /** The field type of the direct answer. */
    fieldType: string;
}

/**
 * Maintains the direct answer associated with the latest search.
 *
 * @public
 */
export declare interface DirectAnswerState {
    /**
     * The data for the direct answer. The type of the data is determined by the
     * Answers API based on whether the answer was found within a document or was a
     * field value in the knowledge graph.
     */
    result?: FeaturedSnippetDirectAnswer | FieldValueDirectAnswer;
}

/**
 * Represents the type of direct answer.
 *
 * @public
 */
export declare enum DirectAnswerType {
    /** Indicates that the DirectAnswer is a {@link FeaturedSnippetDirectAnswer}. */
    FeaturedSnippet = "FEATURED_SNIPPET",
    /** Indicates that the DirectAnswer is a {@link FieldValueDirectAnswer}. */
    FieldValue = "FIELD_VALUE"
}

/**
 * The direction of a sort.
 *
 * @public
 */
export declare enum Direction {
    /**
     *  An ascending sort
     *
     * @remarks
     * For numbers this sort is low to high. For text it is alphabetical. For dates it is chronological order.
     */
    Ascending = "ASC",
    /**
     * A descending soft
     *
     * @remarks
     * For numbers this sort is high to low. For text it is reverse alphabetical. For dates it is reverse
     * chronological order.
     */
    Descending = "DESC"
}

/**
 * A {@link Facet} which contains extra fields meant to be displayed to the end user.
 *
 * @public
 */
export declare interface DisplayableFacet extends Facet {
    /** {@inheritDoc Facet.fieldId} */
    fieldId: string;
    /** An array of {@link DisplayableFacetOption} */
    options: DisplayableFacetOption[];
    /** The name of the facet which is meant to be displayed to the user. */
    displayName: string;
}

/**
 * A {@link FacetOption} with extra data meant to be displayed to the end user.
 *
 * @public
 */
export declare interface DisplayableFacetOption extends FacetOption {
    /** {@inheritDoc Matcher} */
    matcher: Matcher;
    /** {@inheritDoc FacetOption.value} */
    value: string | number | boolean | NumberRangeValue;
    /** The name of the facet option which is meant  to be displayed to the end user. */
    displayName: string;
    /** The number of results associated with this facet option. */
    count: number;
    /** Whether or not the filter is selected in the search results. */
    selected: boolean;
}

/**
 * Overrides for the URLs which are used when making requests to the Answers API.
 *
 * @public
 */
export declare interface Endpoints {
    universalSearch?: string;
    verticalSearch?: string;
    questionSubmission?: string;
    status?: string;
    universalAutocomplete?: string;
    verticalAutocomplete?: string;
    filterSearch?: string;
}

/**
 * Produces a union type from the enum passed as a generic which consists of the enum values
 * and the string literals of the enum.
 * @public
 */
export declare type EnumOrLiteral<T extends string> = T | `${T}`;

/**
 * Identifier for the type of error causing the failure.
 *
 * @public
 */
export declare enum ErrorType {
    /** A timeout error from the server. */
    Timeout = "TIMEOUT",
    /** An internal error from the API backend. */
    BackendError = "BACKEND_ERROR",
    /** An invalid config from the request. */
    InvalidConfig = "INVALID_CONFIG",
    /** An invalid query from the request. */
    InvalidQuery = "INVALID_QUERY"
}

/**
 * Represents dynamic filter options for the Answers API.
 *
 * @public
 */
export declare interface Facet {
    /** The associated fieldId. */
    fieldId: string;
    /**
     * An array of {@link FacetOption}
     *
     * @remarks
     * To indicate that a facet should be disabled, supply an empty array
     */
    options: FacetOption[];
}

/**
 * A filter associated with the facet.
 *
 * @public
 */
export declare interface FacetOption {
    /** {@inheritDoc Matcher} */
    matcher: Matcher;
    /**
     * The value to compare.
     *
     * @example
     * 'Sales'
     */
    value: string | number | boolean | NumberRangeValue;
}

/**
 * Error information from when a vertical fails to return results.
 *
 * @public
 */
export declare interface FailedVertical {
    /** The vertical key associated with the failed vertical. */
    verticalKey: string;
    /** {@inheritDoc ErrorType} */
    errorType: ErrorType;
    /** The duration of the query in milliseconds. */
    queryDurationMillis: number;
    /** Detailed information about the error. */
    details: {
        /**
         * An HTTP response status code indicating the completion status of
         * the request.
         */
        responseCode: number;
        /** A message explaining the error. */
        description: string;
    };
}

/**
 * A direct answer which was found within a document.
 *
 * @public
 */
export declare interface FeaturedSnippetDirectAnswer extends DirectAnswer {
    /** {@link DirectAnswerType}.FeaturedSnippet. */
    type: DirectAnswerType.FeaturedSnippet;
    /** {@inheritDoc DirectAnswer.value} */
    value?: string;
    /** {@inheritDoc DirectAnswer.relatedResult} */
    relatedResult: Result;
    /** {@inheritDoc DirectAnswer.verticalKey} */
    verticalKey: string;
    /** {@inheritDoc DirectAnswer.fieldType} */
    fieldType: string;
    /** The snippet where the direct answer was found. */
    snippet: Snippet;
}

/**
 * A direct answer where the answer came from a field from the knowledge graph.
 *
 * @public
 */
export declare interface FieldValueDirectAnswer extends DirectAnswer {
    /** {@link DirectAnswerType}.FieldValue. */
    type: DirectAnswerType.FieldValue;
    /** {@inheritDoc DirectAnswer.value} */
    value: string;
    /** {@inheritDoc DirectAnswer.relatedResult} */
    relatedResult: Result;
    /** {@inheritDoc DirectAnswer.verticalKey} */
    verticalKey: string;
    /** {@inheritDoc DirectAnswer.fieldType} */
    fieldType: string;
    /** The name of the entity that direct answer came from. */
    entityName: string;
    /** The field name of the direct answer. */
    fieldName: string;
    /** The field api name of the direct answer. */
    fieldApiName: string;
}

/**
 * Represents a filter which compares values to a single field.
 *
 * @public
 */
export declare interface Filter {
    /**
     * The fieldId to apply the filter against.
     *
     * @example
     * 'c_jobCategory'
     */
    fieldId: string;
    /** {@inheritDoc Matcher} */
    matcher: Matcher;
    /**
     * The value to compare.
     *
     * @example
     * 'Sales'
     */
    value: string | number | boolean | NearFilterValue | NumberRangeValue;
}

/**
 * Indicates how the filters in a {@link CombinedFilter} should be combined.
 *
 * @public
 */
export declare enum FilterCombinator {
    /** Indicates that filters should be combined with a logical AND. */
    AND = "$and",
    /** Indicates that filters should be combined with a logical OR. */
    OR = "$or"
}

/**
 * Options for a filtersearch request.
 *
 * @public
 */
export declare interface FilterSearchRequest extends AnswersRequest {
    /** {@inheritDoc UniversalAutocompleteRequest.input} */
    input: string;
    /** {@inheritDoc UniversalAutocompleteRequest.sessionTrackingEnabled} */
    sessionTrackingEnabled?: boolean;
    /** {@inheritDoc VerticalAutocompleteRequest.verticalKey} */
    verticalKey: string;
    /** Determines whether or not the results of the {@link FilterSearchResponse} are separated by field. */
    sectioned: boolean;
    /** An array of {@link SearchParameterField} */
    fields: SearchParameterField[];
    /** an array of filters that should be excluded from filter search results. */
    excluded?: Filter[];
}

/**
 * The response of a filtersearch request.
 *
 * @public
 */
export declare interface FilterSearchResponse {
    /**
     * Represents autocomplete results separated by field.
     *
     * @remarks
     * If sectioned is true, the matching filters will be returned in a separate section per field.
     * By default, they are all returned in the same section.
     */
    sections: {
        /** A display label for the field.
         *
         * @remarks
         * When sectioned is false, there's no label since all filters wil be returned in same section.
         */
        label?: string;
        /** An array of {@link AutocompleteResult}s. */
        results: AutocompleteResult[];
    }[];
    /** ID of the account associated with this Answers experience */
    businessId?: string;
    /** {@inheritDoc AutocompleteResponse.queryId} */
    queryId?: string;
    /** A unique id which corresponds to the request. */
    uuid: string;
}

/**
 * Maintains the current state of facets and filters in the application.
 *
 * @public
 */
export declare interface FiltersState {
    /**
     * The collection of possible static filters that can be applied to the
     * search results and whether each of them is currently selected.
     */
    static?: SelectableFilter[];
    /**
     * The dynamic collection of facets that can be applied to filter the search
     * results and whether each of them is currently selected.
     */
    facets?: DisplayableFacet[];
}

/**
 * A union type for the different kinds of filter.
 *
 * @public
 */
export declare type FilterTypes = Filter | CombinedFilter;

/**
 * The configuration for an AnswersHeadless instance.
 *
 * @public
 */
export declare type HeadlessConfig = AnswersConfig & {
    /**
     * The ID of the AnswersHeadless instance.
     *
     * @remarks
     * Must be different from {@link DEFAULT_HEADLESS_ID}.
     */
    headlessId?: string;
    /**
     * The verticalKey associated with the vertical to manage. If none is provided,
     * Answers Headless will manage universal search.
     */
    verticalKey?: string;
};

/**
 * A mapping of fields to the values emphasized by the Answers API
 *
 * @remarks
 * Only fields that have been marked as highlighted will be present - which may not be
 * all fields of the corresponding {@link Result}'s rawData.
 * Fields that are present will match the rawData's structure and order.
 *
 * @example
 * If a user searches for 'apple', the API will likely match fields that contain
 * the word 'apple'.
 *
 * ```js
 * {
 *   description: {
 *     value: 'likes apple pie and green apples',
 *     matchedSubstrings: [
 *       { offset: 6, length: 5 },
 *       { offset: 26, length: 5 }
 *     ]
 *   },
 *   c_favoriteFruits: [
 *     {
 *       apples: [
 *         {
 *           value: 'Granny Smith',
 *           matchedSubstrings: []
 *         },
 *         {
 *           value: 'Upton Pyne Apple',
 *           matchedSubstrings: [{ offset: 11, length: 5}]
 *         }
 *       ],
 *       pears: [
 *         {
 *           value: 'Callery Pear',
 *           matchedSubstrings: []
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * @public
 */
export declare type HighlightedFields = {
    /**
     * A mapping of a field to either an array of HighlightedFields, HighlightedFields for
     * this field's subfields, or a {@link HighlightedValue} for the field.
     *
     * @remarks
     * HighlightedFields is an object of arbitrary shape which contains {@link HighlightedValue} objects.
     */
    [fieldId: string]: HighlightedValue | HighlightedValue[] | HighlightedFields | HighlightedFields[];
};

/**
 * A field value and its substring matches as emphasized by the Answers API.
 *
 * @public
 */
export declare interface HighlightedValue {
    /**
     * The value of the field which should be highlighted.
     *
     * @remarks
     * No formatting is applied to this value. This is simply the value that
     * the Answers API determined should be highlighted.
     */
    value: string;
    /**
     * An array of substring matches which correspond to the highlighting.
     *
     * @remarks
     * Offset indicates the index of the match, and the length indicates the number of characters of the match.
     *
     * @example
     * A user may search for 'Yext', and the result may include the value
     * 'Yext is a search company'. The matched substrings would correspond
     * to 'Yext' and the matchedSubstrings array would be: `[{ length: 4, offset: 0 }]`
     */
    matchedSubstrings: {
        length: number;
        offset: number;
    }[];
}

/**
 * Assigns numeric IDs to every http request and the corresponding response
 * through {@link AnswersCore}. This helps track the received order of requests
 * and responses. {@link AnswersHeadless} uses it to ensure dispatch events for
 * state updates are triggered with up-to-date responses (e.g. if the newly received
 * response has a higher ID number than the recorded received response).
 */
declare class HttpManager {
    private latestRequestIds;
    private latestResponseIds;
    constructor();
    updateRequestId(requestName: ServiceType): number;
    setResponseId(responseName: ServiceType, responseId: number): void;
    getLatestResponseId(responseName: ServiceType): number;
    /**
     * Update the latest saved response id of the given service type if
     * the given request id is newer than the latest saved response id.
     *
     * @param requestName - the request type.
     * @param requestId - the request id of a received response.
     *
     * @returns Whether the response of the given request id is the latest response.
     */
    processRequestId(requestName: ServiceType, requestId: number): boolean;
}

/**
 * Checks if the searchTerm is a case-insensitive, Levenshtein match for the value.
 *
 * @param value - The string to compare against
 * @param searchTerm - The term being searched for
 * @returns Whether or not the searchTerm is a substring of or a close Levenshtein match
 *          for the value
 *
 * @public
 */
declare function isCloseMatch(value: string, searchTerm: string): boolean;

/**
 * The latitude and longitude of the user making the request.
 * Used to bias the results.
 *
 * @remarks
 * If omitted from a request, Yext will attempt to determine the location.
 *
 * @public
 */
export declare interface LatLong {
    /**
     * Latitude formatted as a decimal degree number.
     *
     * @example
     * `40.741895`
     */
    latitude: number;
    /**
     * Longitude formatted as a decimal degree number.
     *
     * @example
     * `-73.989308`
     */
    longitude: number;
}

/**
 * Information about the user's location.
 *
 * @public
 */
export declare interface LocationBias {
    /** The location's latitude. */
    latitude: number;
    /** The location's longitude. */
    longitude: number;
    /**
     * The name of the location.
     *
     * @example
     * Arlington, Virginia.
     */
    displayName: string;
    /** {@inheritDoc LocationBiasMethod} */
    method: LocationBiasMethod;
}

/**
 * The method used to determine the location.
 *
 * @public
 */
export declare enum LocationBiasMethod {
    /** Location was determined by IP address. */
    Ip = "IP",
    /**
     * Location was supplied by the user's device.
     *
     * @remarks
     * This location bias method is set when a location is supplied in search requests.
     * */
    Device = "DEVICE",
    /**
     * Location is unknown.
     */
    Unknown = "UNKNOWN"
}

/**
 * Location boundaries for a filter with "Place" for its {@link AppliedQueryFilterType}.
 * (e.g. boundary for a locality or region specific location filter)
 *
 * @public
 */
export declare interface LocationBoundingBox {
    /** The location's highest latitude degree. */
    maxLatitude: number;
    /** The location's highest longitude degree. */
    maxLongitude: number;
    /** The location's lowest latitude degree. */
    minLatitude: number;
    /** The location's lowest longitude degree. */
    minLongitude: number;
}

/**
 * Additional details relevant to the filter with "PLACE" for its {@link AppliedQueryFilterType}.
 *
 * @public
 */
export declare interface LocationFilterDetails {
    /** The location's latitude. */
    latitude: number;
    /** The location's longitude. */
    longitude: number;
    /** The location's name. */
    placeName: string;
    /** The location's classification (e.g. locality, region, address). */
    featureTypes: string[];
    /** The location's coordinate boundaries. */
    boundingBox?: LocationBoundingBox;
}

/**
 * Maintains the user's location, if given, or the inferred location, that is
 * used to bias search results.
 *
 * @public
 */
export declare interface LocationState {
    /**
     * The geographical location bias used in the search, returned from the
     * Answers API.
     */
    locationBias?: LocationBias;
    /**
     * The latitude and longitude of the user making the request. Used to bias
     * the results.
     */
    userLocation?: LatLong;
}

/**
 * The start limit of {@link NumberRangeValue}.
 *
 * @public
 */
export declare interface LowerNumberRangeLimit {
    /** {@link Matcher} for the start limit */
    matcher: Matcher.GreaterThan | Matcher.GreaterThanOrEqualTo;
    /** Value of the limit. */
    value: number;
}

/**
 * A Matcher is a filtering operation.
 *
 * @public
 */
export declare enum Matcher {
    /**
     * An equals comparison.
     *
     * @remarks
     * Compatible with all field types.
     */
    Equals = "$eq",
    /**
     * A not equals comparison.
     *
     * @remarks
     * Compatible with all field types.
     */
    NotEquals = "!$eq",
    /**
     * A less than comparison.
     *
     * @remarks
     * Compatible with integer, float, date, datetime, and time fields.
     */
    LessThan = "$lt",
    /**
     * A less than or equal to comparison.
     *
     * @remarks
     * Compatible with integer, float, date, datetime, and time fields.
     */
    LessThanOrEqualTo = "$le",
    /**
     * A greater than comparison.
     *
     * @remarks
     * Compatible with integer, float, date, datetime, and time fields.
     */
    GreaterThan = "$gt",
    /**
     * A greater than or equal to comparison.
     *
     * @remarks
     * Compatible with integer, float, date, datetime, and time fields.
     */
    GreaterThanOrEqualTo = "$ge",
    /**
     * A comparison of whether an entity is within a certain radius of a certain location.
     *
     * @remarks
     * Only compatible with the builtin.location field.
     */
    Near = "$near",
    /**
     * A limitation of the dataset to a range of values.
     *
     * @remarks
     * Compatible with integer and float.
     */
    Between = "$between"
}

/**
 * Maintains the metadata for Answers Headless.
 *
 * @public
 */
export declare interface MetaState {
    /**
     * A JSON object used for passing data to and triggering Answers
     * {@link https://hitchhikers.yext.com/tracks/answers-advanced/ans302-query-rules/ | Query Rules}.
     */
    context?: Context;
    /**
     * The URL of the referring page (the page that directed to the current page from
     * which the request was made).
     */
    referrerPageUrl?: string;
    /**
     * A unique id which corresponds to the latest request/response.
     */
    uuid?: string;
    /**
     * Indicates the type of search that Answers Headless is managing.
     */
    searchType: SearchType;
}

/**
 * A filter value for a filter with a $near {@link Matcher}.
 *
 * @public
 */
export declare interface NearFilterValue {
    /** The radius (in meters) around the latitude and longitude. */
    radius: number;
    /** The latitude of the location. */
    lat: number;
    /** The longitude of the location. */
    lng: number;
}

/**
 * A filter value for a filter with a $between {@link Matcher}.
 *
 * @public
 */
export declare interface NumberRangeValue {
    /** Start limit of the number range value. */
    start?: LowerNumberRangeLimit;
    /** End limit of the number range value. */
    end?: UpperNumberRangeLimit;
}

/**
 * The overall shape of the redux state tree, with each key value pair of
 * headlessId to {@link State} representing a single AnswersHeadless instance.
 *
 * @public
 */
export declare interface ParentState {
    /**
     * A mapping of the ID of an AnswersHeadless instance to its {@link State}.
     */
    [headlessId: string]: State;
}

/**
 * Supplies a new instance of {@link AnswersHeadless}, using the provided configuration.
 *
 * @param config - The apiKey, experienceKey, etc. needed to set up a front-end Answers
 *                 experience.
 * @returns The newly created instance of {@link AnswersHeadless}
 *
 * @public
 */
export declare function provideAnswersHeadless(config: HeadlessConfig): AnswersHeadless;

/**
 * Supplies a new instance of {@link AnswersHeadless}, using the provided configuration,
 * and accepts additional HTTP headers to pass with API requests.
 *
 * @param config - The apiKey, experienceKey, etc. needed to set up a front-end Answers
 *                 experience
 * @param additionalHttpHeaders - Additional value for specific HTTP headers
 * @returns The newly created instance of {@link AnswersHeadless}
 *
 * @internal
 */
export declare function provideAnswersHeadless(config: HeadlessConfig, additionalHttpHeaders: AdditionalHttpHeaders): AnswersHeadless;

/**
 * Data returned from the Answers query rules system.
 *
 * @public
 */
export declare interface QueryRulesActionsData {
    /**
     * The unique identifier for this query rule.
     */
    key: string;
    /**
     * The data returned from the query rule.
     */
    data?: Record<string, unknown>;
    /**
     * Any errors returned from the query rule.
     */
    errors?: {
        /**
         * The unique identifier of the function invocation that resulted in this error.
         */
        uuid: string;
        /**
         * The type of the error.
         */
        type: string;
        /**
         * A message describing the error.
         */
        message?: string;
    }[];
}

/**
 * Maintains the data from the triggered query rules.
 *
 * @public
 */
export declare interface QueryRulesState {
    /**
     * Any actions triggered by meeting criteria for query rules.
     */
    actions: QueryRulesActionsData[];
}

/**
 * The source of the search request.
 *
 * @public
 */
export declare enum QuerySource {
    /**
     * Indicates that the query was initiated from a standard Answers integration.
     */
    Standard = "STANDARD",
    /**
     * Indicates that the query was initiated from an Answers Overlay.
     */
    Overlay = "OVERLAY",
    /**
     * Indicates that the query was initiated from visual autocomplete.
     */
    Autocomplete = "AUTOCOMPLETE"
}

/**
 * Maintains the latest query and its associated data.
 *
 * @public
 */
export declare interface QueryState {
    /**
     * The user input used for the next search query.
     */
    input?: string;
    /**
     * The ID of the query from the latest search.
     */
    queryId?: string;
    /**
     * How the query was triggered (besides user input).
     */
    queryTrigger?: QueryTrigger;
    /**
     * The source of the query (from a standard Answers integration, an Answers
     * overlay, or from visual autocomplete).
     */
    querySource?: QuerySource;
    /**
     * The query of the most recent search.
     */
    mostRecentSearch?: string;
    /**
     * The computed intents of the mostRecentSearch, as returned by the Answers API.
     */
    searchIntents?: SearchIntent[];
}

/**
 * Describes the ways a search can be executed besides user input.
 *
 * @remarks
 * Used for search analytics. If a user supplied the search query, do not include a QueryTrigger.
 *
 * @example
 * An answers site may be configured to perform a search for 'What services do you offer?' when the page
 * loads. Because that query is a default query rather than a user-supplied query, the Initialize QueryTrigger
 * should be included in the request.
 *
 * @public
 */
export declare enum QueryTrigger {
    /** Indicates that the query was triggered by a default initial search. */
    Initialize = "initialize",
    /** Indicates that the query was suggested by a {@link SpellCheck} response. */
    Suggest = "suggest"
}

/**
 * Options for a QuestionSubmission request.
 *
 * @public
 */
export declare interface QuestionSubmissionRequest extends AnswersRequest {
    /** The email of the user that is submitting the question. */
    email: string;
    /** The ID of the entity to associate with the question. */
    entityId: string;
    /** The name of the user. */
    name: string;
    /** The question. */
    questionText: string;
    /** Additional information about the question. */
    questionDescription?: string;
    /** Enables session tracking. */
    sessionTrackingEnabled?: boolean;
}

/**
 * A representation of a question submission response.
 *
 * @public
 */
export declare interface QuestionSubmissionResponse {
    /** A unique id which corresponds to the request. */
    uuid: string;
}

/**
 * Submits a custom question to the Answers API.
 *
 * @public
 */
export declare interface QuestionSubmissionService {
    /**
     * Submits a question to be answered.
     *
     * @param request - The question, as well as the contact info of the submitter.
     */
    submitQuestion(request: QuestionSubmissionRequest): Promise<QuestionSubmissionResponse>;
}

/**
 * A boundary for a {@link BoundedRange} of type T.
 *
 * @public
 */
export declare interface RangeBoundary<T> {
    /**
     * The value of the boundary.
     */
    value: T;
    /**
     * Whether or not the range includes the boundary value.
     */
    inclusive: boolean;
}

/**
 * An individual search result.
 *
 * @public
 */
export declare interface Result {
    /** Raw entity profile data in the shape of key-value pairs. */
    rawData: Record<string, unknown>;
    /** {@inheritDoc Source}*/
    source: Source;
    /** The index of the result among the other results in the search. */
    index?: number;
    /** The name of the result. */
    name?: string;
    /** A description of the result. */
    description?: string;
    /** A hyperlink associated with the result. */
    link?: string;
    /** The result ID which depends on the Result Source. */
    id?: string;
    /** The distance from the user to the result in meters. */
    distance?: number;
    /**
     * The distance from a {@link AppliedQueryFilter} location to the result in meters.
     *
     * @remarks
     * The filter may be an inferred from the search query, or it may be specified
     * explicitly through a facet or static filter on a {@link VerticalSearchRequest}.
     *
     * @example
     * If a user searches for 'Offices in New York' and the VerticalResults contain an
     * `AppliedQueryFilter` for 'New York', the distanceFromFilter value will be from
     * the search result to 'New York'.
     */
    distanceFromFilter?: number;
    /** The {@link HighlightedFields | highlighted fields} emphasized by the api. */
    highlightedFields?: HighlightedFields;
    /** The entity type of the result */
    entityType?: string;
}

/**
 * The endpoints to use for sandbox experiences.
 *
 * @public
 */
export declare const SandboxEndpoints: Required<Endpoints>;

/**
 * Represents intents from the Answers API.
 *
 * @public
 */
export declare enum SearchIntent {
    /** The Answers API is requesting a prompt for the user's location. */
    NearMe = "NEAR_ME"
}

/**
 * Indicates which entity field to perform the autocomplete request on.
 *
 * @public
 */
export declare interface SearchParameterField {
    /** The fieldApiName to perform the autocomplete on. */
    fieldApiName: string;
    /** The entityType to perform the autocomplete on. */
    entityType: string;
    /**
     * Indicates whether or not to return the {@link AutocompleteResult.relatedItem}
     * associated with the autocomplete result.
     */
    fetchEntities: boolean;
}

/**
 * A service which performs Yext Answers searches
 *
 * @public
 */
export declare interface SearchService {
    /**
     * Performs a Universal search across all verticals.
     *
     * @param request - The details of the Universal search request.
     */
    universalSearch(request: UniversalSearchRequest): Promise<UniversalSearchResponse>;
    /**
     * Performs a search across a particular Vertical.
     *
     * @param request - The details of the Vertical search request.
     */
    verticalSearch(request: VerticalSearchRequest): Promise<VerticalSearchResponse>;
}

/**
 * Maintains the status of the latest search.
 *
 * @public
 */
export declare interface SearchStatusState {
    /**
     * Whether a search is currently loading or has finished loading.
     */
    isLoading?: boolean;
}

/**
 * Searches through the specified facet and filters out the options that aren't a
 * close match for the given searchTerm. The comparison is case insensitive.
 *
 * @param facet - The facet whose options are searched through
 * @param searchTerm - The search term to compare the facet options against
 * @returns The facet with only its options that are a close match for the
 *          searchTerm
 *
 * @public
 */
declare function searchThroughFacet(facet: DisplayableFacet, searchTerm: string): DisplayableFacet;

/**
 * An enum and its corresponding string literals which indicate the type of search that Headless is managing.
 *
 * @public
 */
export declare type SearchType = EnumOrLiteral<SearchTypeEnum>;

/**
 * An enum which indicates the type of search that Headless is managing.
 *
 * @public
 */
export declare enum SearchTypeEnum {
    /**
     * Indicates that headless is managing universal search.
     */
    Universal = "universal",
    /**
     * Indicates that headless is managing vertical search.
     */
    Vertical = "vertical"
}

/**
 * A {@link Filter} with additional information, such as an
 * optional display name and whether or not it is selected.
 *
 * @public
 */
export declare interface SelectableFilter extends Filter {
    /**
     * Whether or not the filter is selected.
     */
    selected: boolean;
    /**
     * The filter's display name.
     */
    displayName?: string;
}

declare type ServiceType = 'universalQuery' | 'verticalQuery';

/**
 * Maintains whether the user session should be tracked and, if so, the session
 * information.
 *
 * @public
 */
export declare interface SessionTrackingState {
    /**
     * Whether or not session tracking is enabled.
     */
    enabled?: boolean;
    /**
     * The ID of the current session. Used to track session state when cookies
     * are blocked.
     */
    sessionId?: string;
}

/**
 * The section of text where a {@link FeaturedSnippetDirectAnswer} was found.
 *
 * @public
 */
export declare interface Snippet {
    /** The snippet's body of text */
    value: string;
    /** The locations in the document text of the {@link FeaturedSnippetDirectAnswer.value} */
    matchedSubstrings: {
        offset: number;
        length: number;
    }[];
}

/**
 * Represents a criterion that can be used to sort results.
 *
 * @remarks
 * Overrides the sort options that are configured on the experience configuration.
 *
 * @public
 */
export declare interface SortBy {
    /** {@inheritDoc SortType} */
    type: SortType;
    /** The field name to sort by. Required if the SortBy type is {@link SortType.Field}. */
    field?: string;
    /** The direction of the sort. Required if the SortBy type is {@link SortType.Field}. */
    direction?: Direction;
}

/**
 * The method of sorting.
 *
 * @public
 */
export declare enum SortType {
    /**
     * Sorts based on a field with the direction specified.
     */
    Field = "FIELD",
    /**
     * Sorts based on entity distance alone.
     */
    EntityDistance = "ENTITY_DISTANCE",
    /**
     * Sorts based on relevance according to the algorithm and, when relevant, location bias.
     */
    Relevance = "RELEVANCE"
}

/**
 * Represents the source of a {@link Result}.
 *
 * @public
 */
export declare enum Source {
    /** The result is from an Answers Knowledge Graph. */
    KnowledgeManager = "KNOWLEDGE_MANAGER",
    /** The result is from Google Custom Search Engine. */
    Google = "GOOGLE_CSE",
    /** The result is from Bing Search Engine. */
    Bing = "BING_CSE",
    /** The result is from Zendesk. */
    Zendesk = "ZENDESK",
    /** The result is from Algolia. */
    Algolia = "ALGOLIA",
    /** The result was from a custom source. */
    Custom = "CUSTOM_SEARCHER"
}

/**
 * A spellcheck response from a search query.
 *
 * @public
 */
export declare interface SpellCheck {
    /** The query that was input into the spell checker. */
    originalQuery: string;
    /** The corrected version of the originalQuery. */
    correctedQuery: string;
    /** The type of spell check. */
    type: SpellCheckType;
}

/**
 * Maintains whether spellcheck is enabled and the spellcheck response from the
 * latest search.
 *
 * @public
 */
export declare interface SpellCheckState extends Partial<SpellCheck> {
    /**
     * Whether or not spellcheck is enabled.
     */
    enabled: boolean;
}

/**
 * Represents the type of spell check performed.
 *
 * @public
 */
export declare enum SpellCheckType {
    /** The API is suggesting an alternative query. */
    Suggest = "SUGGEST",
    /** The API is autocorrecting the original query. */
    AutoCorrect = "AUTOCORRECT",
    /** The API may be doing some combination of suggesting or autocorrecting. */
    Combine = "COMBINE"
}

/**
 * The state representing an AnswersHeadless instance.
 *
 * @public
 */
export declare interface State {
    /**
     * {@inheritDoc QueryState}
     */
    query: QueryState;
    /**
     * {@inheritDoc UniversalSearchState}
     */
    universal: UniversalSearchState;
    /**
     * {@inheritDoc VerticalSearchState}
     */
    vertical: VerticalSearchState;
    /**
     * {@inheritDoc DirectAnswerState}
     */
    directAnswer: DirectAnswerState;
    /**
     * {@inheritDoc QueryRulesState}
     */
    queryRules: QueryRulesState;
    /**
     * {@inheritDoc FiltersState}
     */
    filters: FiltersState;
    /**
     * {@inheritDoc SearchStatusState}
     */
    searchStatus: SearchStatusState;
    /**
     * {@inheritDoc SpellCheckState}
     */
    spellCheck: SpellCheckState;
    /**
     * {@inheritDoc SessionTrackingState}
     */
    sessionTracking: SessionTrackingState;
    /**
     * {@inheritDoc MetaState}
     */
    meta: MetaState;
    /**
     * {@inheritDoc LocationState}
     */
    location: LocationState;
}

/**
 * Represents a listener for a specific value of type T in the state.
 *
 * @public
 */
export declare interface StateListener<T> {
    /**
     * Accesses a value of type T in the state.
     *
     * @param state - The current state
     * @returns The value of type T from the state
     */
    valueAccessor(state: State): T;
    /**
     * The function to call when the state value updates.
     *
     * @param currentValue - The current state value
     */
    callback(currentValue: T): any;
}

/**
 * Manages the information contained in the state for an AnswersHeadless instance.
 *
 * @remarks
 * The {@link State} is immutable, and can only be updated by dispatched events.
 *
 * @public
 */
export declare interface StateManager {
    /**
     * Returns the current state.
     */
    getState(): State;
    /**
     * Dispatches an event. This can update the {@link State}.
     *
     * @param type - The type of action to dispatch
     * @param payload - The payload of the action to dispatch
     */
    dispatchEvent(type: string, payload?: unknown): void;
    /**
     * Adds a listener for a specific state value of type T.
     *
     * @param listener - The state listener to add
     * @returns The function for removing the added listener
     */
    addListener<T>(listener: StateListener<T>): Unsubscribe;
}

/**
 * Options for a universal autocomplete request.
 *
 * @public
 */
export declare interface UniversalAutocompleteRequest extends AnswersRequest {
    /** The input string for autocomplete. */
    input: string;
    /** Enables session tracking. */
    sessionTrackingEnabled?: boolean;
}

/**
 * The maximum limit of results per vertical.
 * Each limit can be set from 1-50, inclusive.
 *
 * @example
 * \{
 *    people: 5,
 *    locations: 10,
 *    events: 8
 * \}
 *
 * @public
 */
export declare interface UniversalLimit {
    [verticalKey: string]: number;
}

/**
 * Options which can be specified for a universal search.
 *
 * @public
 */
export declare interface UniversalSearchRequest extends AnswersRequest {
    /** The search query. */
    query: string;
    /** {@inheritDoc QueryTrigger} */
    queryTrigger?: QueryTrigger;
    /** Disables spellcheck if true. */
    skipSpellCheck?: boolean;
    /** Used to track session state when cookies are blocked. */
    sessionId?: string;
    /** Enables session tracking. */
    sessionTrackingEnabled?: boolean;
    /** {@inheritDoc LatLong} */
    location?: LatLong;
    /** {@inheritDoc Context} */
    context?: Context;
    /**
     * The URl of the page which referred the user to the current page.
     *
     * @example
     * If a user is on https://www.yext.com/ and navigates to https://www.yext.com/answers and perform a search,
     * the referrerPageUrl would be https://www.yext.com/.
     */
    referrerPageUrl?: string;
    /** {@inheritDoc QuerySource} */
    querySource?: QuerySource | string;
    /** {@inheritDoc UniversalLimit} */
    limit?: UniversalLimit;
    /** If included, the response will only include these verticals. */
    restrictVerticals?: string[];
}

/**
 * A representation of a response from a universal search.
 *
 * @public
 */
export declare interface UniversalSearchResponse {
    /** An array of {@link VerticalResults} which represent the results for each vertical. */
    verticalResults: VerticalResults[];
    /** The ID of the search query. */
    queryId?: string;
    /** {@inheritDoc DirectAnswer} */
    directAnswer?: FeaturedSnippetDirectAnswer | FieldValueDirectAnswer;
    /** An array of {@link SearchIntent}s which represents requests from the API. */
    searchIntents?: SearchIntent[];
    /** {@inheritDoc SpellCheck} */
    spellCheck?: SpellCheck;
    /** {@inheritDoc LocationBias} */
    locationBias?: LocationBias;
    /** A unique id which corresponds to the request. */
    uuid: string;
    /** {@inheritDoc QueryRulesActionsData} */
    queryRulesActionsData?: QueryRulesActionsData[];
    /** {@inheritDoc FailedVertical} */
    failedVerticals?: FailedVertical[];
}

/**
 * Maintains the data for the latest universal search.
 *
 * @public
 */
export declare interface UniversalSearchState {
    /**
     * An object defining the limit (up to how many results should be returned) for
     * each vertical.
     */
    limit?: UniversalLimit;
    /**
     * The results from each vertical included in the universal search.
     */
    verticals?: VerticalResults[];
    /**
     * If included, the verticals to which the universal search should be restricted.
     */
    restrictVerticals?: string[];
}

/**
 * The end limit of {@link NumberRangeValue}.
 *
 * @public
 */
export declare interface UpperNumberRangeLimit {
    /** {@link Matcher} for the end limit */
    matcher: Matcher.LessThan | Matcher.LessThanOrEqualTo;
    /** Value of the limit. */
    value: number;
}

/**
 * Options for a vertial autocomplete request.
 *
 * @public
 */
export declare interface VerticalAutocompleteRequest extends AnswersRequest {
    /** {@inheritDoc UniversalAutocompleteRequest.input} */
    input: string;
    /** {@inheritDoc UniversalAutocompleteRequest.sessionTrackingEnabled} */
    sessionTrackingEnabled?: boolean;
    /** The key for the vertical to get autocomplete suggestions from. */
    verticalKey: string;
}

/**
 * Represents results from a search vertical.
 *
 * @public
 */
export declare interface VerticalResults {
    /** A array of {@link AppliedQueryFilter}s which were applied to the vertical results. */
    appliedQueryFilters: AppliedQueryFilter[];
    /** The duration of the query in milliseconds. */
    queryDurationMillis: number;
    /** An array of search {@link Result}s for the vertical. */
    results: Result[];
    /**
     * The total number of results within the vertical.
     *
     * @remarks
     * This number may be higher than the number of results in the results array
     * since the API limits the number of results returned in each request.
     */
    resultsCount: number;
    /** {@inheritDoc Source} */
    source: Source;
    /** The vertical key associated with the vertical results. */
    verticalKey: string;
}

/**
 * Options which can be specified for a vertical search.
 *
 * @public
 */
export declare interface VerticalSearchRequest extends AnswersRequest {
    /** The search query. */
    query: string;
    /** The key associated with the vertical. */
    verticalKey: string;
    /** {@inheritDoc Context} */
    context?: Context;
    /** The maximum number of results to include with a max of 50. */
    limit?: number;
    /** The result offset which allows for fetching more results with the same query. */
    offset?: number;
    /** Indicates that facets should be retrieved. */
    retrieveFacets?: boolean;
    /** The facet filters to apply to the search. */
    facets?: Facet[];
    /** Skips spell checking if true. */
    skipSpellCheck?: boolean;
    /** {@inheritDoc LatLong} */
    location?: LatLong;
    /** {@inheritDoc QueryTrigger} */
    queryTrigger?: QueryTrigger;
    /** Used to track session state when cookies are blocked. */
    sessionId?: string;
    /** Enables session tracking. */
    sessionTrackingEnabled?: boolean;
    /** The static filters to apply to the search. */
    staticFilters?: CombinedFilter | Filter;
    /** Determines how results are sorted. **/
    sortBys?: SortBy[];
    /** {@inheritdoc UniversalSearchRequest.referrerPageUrl} */
    referrerPageUrl?: string;
    /** {@inheritDoc QuerySource} */
    querySource?: QuerySource | string;
    /** The radius (in meters) to filter the vertical search by. */
    locationRadius?: number;
    /** The queryId for the query, if this is a repeat query. */
    queryId?: string;
}

/**
 * A representation of a response from a vertical search.
 *
 * @public
 */
export declare interface VerticalSearchResponse {
    /** {@inheritDoc VerticalResults} */
    verticalResults: VerticalResults;
    /** The ID of the query. */
    queryId: string;
    /** {@inheritDoc DirectAnswer} */
    directAnswer?: FeaturedSnippetDirectAnswer | FieldValueDirectAnswer;
    /** An array of {@link SearchIntent}s. */
    searchIntents?: SearchIntent[];
    /** An array of {@link Facet}s associated with the search results. */
    facets?: DisplayableFacet[];
    /** {@inheritDoc SpellCheck} */
    spellCheck?: SpellCheck;
    /** {@inheritDoc LocationBias} */
    locationBias?: LocationBias;
    /** {@inheritDoc VerticalSearchResponse} */
    allResultsForVertical?: VerticalSearchResponse;
    /** The {@link VerticalResults} for each search vertical. */
    alternativeVerticals?: VerticalResults[];
    /** A unique id which corresponds to the request. */
    uuid: string;
    /** {@inheritDoc QueryRulesActionsData} */
    queryRulesActionsData?: QueryRulesActionsData[];
}

/**
 * Maintains the data for the latest vertical search.
 *
 * @public
 */
export declare interface VerticalSearchState {
    /**
     * The array of filters inferred from the query and applied to the search.
     */
    appliedQueryFilters?: AppliedQueryFilter[];
    /**
     * Name to be displayed for the vertical.
     */
    displayName?: string;
    /**
     * The maximum number of results to include for the vertical search.
     */
    limit?: number;
    /**
     * The data for when no results are returned in the vertical search.
     */
    noResults?: {
        /**
         * {@inheritDoc AllResultsForVertical}
         */
        allResultsForVertical: AllResultsForVertical;
        /**
         * The results from other verticals in the experience.
         */
        alternativeVerticals: VerticalResults[];
    };
    /**
     * The number of results that should be skipped when fetching results for the
     * response. Allows for fetching more results with the same query.
     */
    offset?: number;
    /**
     * The duration of the query in milliseconds.
     */
    queryDurationMillis?: number;
    /**
     * The results from the vertical search.
     */
    results?: Result[];
    /**
     * The number of results for the vertical search.
     */
    resultsCount?: number;
    /**
     * The criteria by which the results should be sorted, in the order in which they
     * should be applied.
     */
    sortBys?: SortBy[];
    /**
     * The source of the vertical search results.
     */
    source?: Source;
    /**
     * The key associated with the vertical.
     */
    verticalKey?: string;
}

/**
 * Information used to associate requests with a particular user.
 *
 * @remarks
 * Visitor information is included with every request with the exception of question submission requests.
 *
 * @public
 */
export declare interface Visitor {
    /** The ID associated with the user */
    id: string;
    /** The type of visitor
     *
     * @example 'YEXT_USER' for Yext Auth
     */
    idMethod?: string;
}

export { }
