function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Takes theme object and returns the new one, properties of which start with the given prefix
 *
 * @param {Object} [theme] - Theme object
 * @param {string} [prefix] - Prefix to filter out theme properties that don't start with it
 *
 * @returns {Object}
 *
 * @example
 * filterThemeWithPrefix({a: 'Comp_a', b: 'Comp_b', item-x: 'Comp_item-x', item-y: 'Comp_item-y'}, 'item-');
 * =>
 * {x: 'Comp_item-x', y: 'Comp_item-y'}
 */
function filterThemeWithPrefix(theme, prefix) {
  var prefixLength = prefix.length;
  var result = {}; // for..in plus indexOf is still the fastest way to filter object

  for (var key in theme) {
    if (theme.hasOwnProperty(key) && key.indexOf(prefix) === 0) {
      result[key.substr(prefixLength)] = theme[key];
    }
  }

  return result;
}

/**
 * Find classes in specified theme that are composed into another classes,
 * i.e. classes that have dependencies in another classes.
 * (https://github.com/css-modules/css-modules#composition)
 *
 * @param {Object} [theme] - Theme object
 * @returns {Object}
 *
 * @example
 * Comp.css
 * .a {...}
 * .b { composes: a; ...}
 * .c { composes: b; ...}
 *
 * getThemeDependencies({
 *   a: 'Comp_a',
 *   b: 'Comp_b Comp_a',
 *   c: 'Comp_c Comp_b Comp_a'
 * });
 * =>
 * {a: ['b', 'c'], b: ['c']}
 */
function getThemeCompositionDependencies(theme) {
  var result = Object.create(null);
  var dependenciesExist = false; // for..in plus indexOf is still the fastest way to filter object

  for (var key in theme) {
    if (theme.hasOwnProperty(key)) {
      // Don't use /\b${theme[key]}\b/ regex here, indexOf on string wrapped in spaces is much faster
      var search = " " + theme[key] + " ";

      for (var anotherKey in theme) {
        if (theme.hasOwnProperty(anotherKey) && anotherKey !== key && (theme[anotherKey] + ' ').indexOf(search) !== -1) {
          if (result[key] === undefined) {
            dependenciesExist = true;
            result[key] = [anotherKey];
          } else {
            result[key].push(anotherKey);
          }
        }
      }
    }
  }

  if (dependenciesExist) {
    return result;
  }

  return undefined;
}

var Compose;

(function (Compose) {
  Compose["Merge"] = "merge";
  Compose["Assign"] = "assign";
  Compose["Replace"] = "replace";
})(Compose || (Compose = {}));

var composedThemesCacheMap = new WeakMap();
var prefixedThemesCacheMap = new WeakMap();
var dependenciesCacheMap = new WeakMap();
/**
 * Filter theme object with a given prefix and cache the result which will be used on subsequent calls with the same params
 * See {@link filterThemeWithPrefix} for parameters list
 */

var getCachedPrefixedTheme = function getCachedPrefixedTheme(theme, prefix) {
  var ownPrefixedItems = prefixedThemesCacheMap.get(theme);
  var ownPrefixeditem;

  if (ownPrefixedItems === undefined) {
    ownPrefixedItems = [];
    prefixedThemesCacheMap.set(theme, ownPrefixedItems);
  } else {
    ownPrefixeditem = ownPrefixedItems.find(function (item) {
      return item.theme === theme && item.prefix === prefix;
    });
  }

  if (ownPrefixeditem === undefined) {
    ownPrefixeditem = {
      theme: theme,
      prefix: prefix,
      finalTheme: filterThemeWithPrefix(theme, prefix)
    };
    ownPrefixedItems.push(ownPrefixeditem);
  }

  return ownPrefixeditem.finalTheme;
};
/**
 * Search theme object for a class composition and cache the result which will be used on subsequent calls with the same params
 * See {@link getThemeCompositionDependencies} for parameters list
 */


var getCachedThemeCompositionDependencies = function getCachedThemeCompositionDependencies(theme) {
  var dependencies = dependenciesCacheMap.get(theme);

  if (dependencies === undefined) {
    dependencies = getThemeCompositionDependencies(theme);

    if (dependencies !== undefined) {
      dependenciesCacheMap.set(theme, dependencies);
    }
  }

  return dependencies;
};
/**
 * Takes an array of objects, which contain themes and options, and returns a composed theme
 *
 * @param {Object[]} options
 * @param {Object} [options[].theme] - Theme object to compose
 * @param {string} [options[].compose] - Method of composition of current theme with previous one
 * @param {string} [options[].prefix] - Prefix to filter out properties in current theme before composition
 * @param {boolean} [options[].noCache=false] - Whether composed theme should not be cached for specified params.
 *
 * @returns {Object}
 */


var composeTheme = function composeTheme(options) {
  var first = options[0];
  var checkCache = first.noCache !== true;
  var composeMethod = typeof first.compose === 'string' ? first.compose : Compose.Merge;
  var resultTheme;
  var dependencies;

  if (typeof first.prefix === 'string' && first.prefix.length > 0) {
    resultTheme = getCachedPrefixedTheme(first.theme, first.prefix);
  } else {
    resultTheme = first.theme;
  }

  var _loop = function _loop(i) {
    var _options$i = options[i],
        theme = _options$i.theme,
        prefix = _options$i.prefix,
        compose = _options$i.compose,
        noParseComposes = _options$i.noParseComposes,
        _options$i$noCache = _options$i.noCache,
        noCache = _options$i$noCache === void 0 ? false : _options$i$noCache;
    var parseComposes = typeof noParseComposes === 'boolean' ? noParseComposes === false : first.noParseComposes !== true;

    if (typeof compose === 'string') {
      composeMethod = compose;
    }

    if (noCache && checkCache) {
      checkCache = false;
    }

    var composedCachedItem = void 0;

    if (checkCache && composeMethod !== Compose.Replace) {
      var composedThemesCache = composedThemesCacheMap.get(theme);

      if (composedThemesCache === undefined) {
        composedThemesCache = [];
        composedThemesCacheMap.set(theme, composedThemesCache);
      } else {
        composedCachedItem = composedThemesCache.find(function (item) {
          return item.againstTheme === resultTheme && item.prefix === prefix && item.composeMethod === composeMethod && item.parseComposes === parseComposes;
        });

        if (composedCachedItem !== undefined) {
          resultTheme = composedCachedItem.composedTheme;
          return "continue";
        }
      }

      composedCachedItem = {
        againstTheme: resultTheme,
        prefix: prefix,
        composeMethod: composeMethod,
        parseComposes: parseComposes
      };
      composedThemesCache.push(composedCachedItem);
    }

    var composedTheme = void 0;

    if (typeof prefix === 'string' && prefix.length > 0) {
      composedTheme = (noCache ? filterThemeWithPrefix : getCachedPrefixedTheme)(theme, prefix);
    } else {
      composedTheme = theme;
    }

    if (composeMethod === Compose.Replace) {
      resultTheme = composedTheme;

      if (parseComposes && i < options.length - 1) {
        dependencies = checkCache ? getCachedThemeCompositionDependencies(resultTheme) : getThemeCompositionDependencies(resultTheme);
      }

      return "continue";
    } // Get composition dependensies ('composes') of the first theme only when it's needed by the second one


    if (i === 1 && noParseComposes !== true) {
      dependencies = checkCache ? getCachedThemeCompositionDependencies(first.theme) : getThemeCompositionDependencies(first.theme);
    }

    if (composeMethod === Compose.Merge) {
      var composedThemeOriginal = composedTheme;
      composedTheme = _extends({}, resultTheme);

      for (var key in composedThemeOriginal) {
        if (composedThemeOriginal.hasOwnProperty(key)) {
          var targetClasses = composedTheme[key];
          var composingClasses = composedThemeOriginal[key];

          if (targetClasses !== undefined) {
            composingClasses = targetClasses + " " + composingClasses; // Check if other classes depend on this one, and update them as well

            if (parseComposes === true && dependencies !== undefined && dependencies[key] !== undefined) {
              var targetClassRegex = new RegExp("\\b" + targetClasses + "\\b");

              for (var _iterator = dependencies[key], _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var otherKey = _ref;
                // Don't need to check for hasOwnProperty since we create dependencies with Object.create(null)
                composedTheme[otherKey] = composedTheme[otherKey].replace(targetClassRegex, composingClasses);
              }
            }
          }

          composedTheme[key] = composingClasses;
        }
      }
    } else if (composeMethod === Compose.Assign) {
      if (dependencies === undefined || parseComposes === false) {
        composedTheme = _extends({}, resultTheme, {}, composedTheme);
      } else {
        var _composedThemeOriginal = composedTheme;
        composedTheme = _extends({}, resultTheme);

        for (var _key in _composedThemeOriginal) {
          if (_composedThemeOriginal.hasOwnProperty(_key)) {
            var _targetClasses = composedTheme[_key];
            var _composingClasses = _composedThemeOriginal[_key]; // Check if other classes depend on this one, and update them as well

            if (dependencies[_key] !== undefined) {
              var _targetClassRegex = new RegExp("\\b" + _targetClasses + "\\b");

              for (var _iterator2 = dependencies[_key], _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref2 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref2 = _i2.value;
                }

                var _otherKey = _ref2;
                // Don't need to check for hasOwnProperty since we create dependencies with Object.create(null)
                composedTheme[_otherKey] = composedTheme[_otherKey].replace(_targetClassRegex, _composingClasses);
              }
            }

            composedTheme[_key] = _composingClasses;
          }
        }
      }
    }

    if (composedCachedItem !== undefined) {
      composedCachedItem.composedTheme = composedTheme;
    }

    resultTheme = composedTheme;
  };

  for (var i = 1; i < options.length; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }

  return resultTheme;
};

export { Compose, composeTheme, filterThemeWithPrefix, getCachedPrefixedTheme, getCachedThemeCompositionDependencies, getThemeCompositionDependencies };
