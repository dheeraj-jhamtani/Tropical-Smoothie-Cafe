/*! dom-parser-react v0.3.0 @license MIT */
var DOMParserReact = (function (exports, react) {
  'use strict';

  const ELEMENT_NODE = 1;
  const TEXT_NODE = 3;
  const DOCUMENT_NODE = 9;
  const DOCUMENT_FRAGMENT_NODE = 11;

  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";

  let parser;
  const htmlParser = (source) => {
    if (!parser) {
      parser = new DOMParser() ;
    }
    const dom = parser.parseFromString(`<!doctype html><body><template>${source}`, "text/html");
    const nodes = dom.body.firstChild.content.childNodes;
    return nodes.length === 1 ? nodes[0] : { nodeType: DOCUMENT_FRAGMENT_NODE, childNodes: nodes };
  };

  const domPropertyRecord = {
    "accept-charset": "acceptCharset",
    accesskey: "accessKey",
    allowfullscreen: "allowFullScreen",
    autocomplete: "autoComplete",
    autofocus: "autoFocus",
    autoplay: "autoPlay",
    cellpadding: "cellPadding",
    cellspacing: "cellSpacing",
    charset: "charSet",
    classid: "classID",
    class: "className",
    colspan: "colSpan",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    controlslist: "controlsList",
    crossorigin: "crossOrigin",
    datetime: "dateTime",
    enctype: "encType",
    formaction: "formAction",
    formenctype: "formEncType",
    formmethod: "formMethod",
    formnovalidate: "formNoValidate",
    formtarget: "formTarget",
    frameborder: "frameBorder",
    hreflang: "hrefLang",
    for: "htmlFor",
    "http-equiv": "httpEquiv",
    inputmode: "inputMode",
    keyparams: "keyParams",
    keytype: "keyType",
    marginheight: "marginHeight",
    marginwidth: "marginWidth",
    maxlength: "maxLength",
    mediagroup: "mediaGroup",
    minlength: "minLength",
    novalidate: "noValidate",
    radiogroup: "radioGroup",
    readonly: "readOnly",
    rowspan: "rowSpan",
    spellcheck: "spellCheck",
    srcdoc: "srcDoc",
    srclang: "srcLang",
    srcset: "srcSet",
    tabindex: "tabIndex",
    usemap: "useMap"
  };

  const parseStyle = (inlineStyle) => {
    const tokens = inlineStyle.trim().split(/([:;'"\\]|\/\*|\*\/)/);
    const style = {};
    let modeToken = null;
    let isEscape = false;
    let property = "";
    let value = "";
    for (let i = 0, len = tokens.length; i < len; ++i) {
      const token = tokens[i];
      if (!token)
        continue;
      if (modeToken === "/*") {
        if (token === "*/") {
          modeToken = null;
        }
        continue;
      }
      if (isEscape) {
        value += token;
        isEscape = false;
        continue;
      }
      isEscape = token === "\\";
      if (modeToken) {
        value += token;
        if (modeToken === token) {
          modeToken = null;
        }
        continue;
      }
      if (token === ":") {
        property = value.trim().replace(/^-ms-/, "ms-").replace(/-(.)/g, (_, char) => char.toUpperCase());
        value = "";
        continue;
      }
      if (token === ";") {
        style[property] = value.trim();
        property = "";
        value = "";
        continue;
      }
      if (token === "'" || token === '"') {
        value += token;
        modeToken = token;
        continue;
      }
      if (token === "/*") {
        modeToken = token;
        continue;
      }
      value += token;
    }
    value = value.trim();
    if (value) {
      style[property] = value;
    }
    return style;
  };

  const map = Array.prototype.map;
  const parse = (source, options) => {
    const dom = htmlParser(source);
    return transform(dom, options);
  };
  const transform = (node, options) => {
    const nodeType = node.nodeType;
    if (nodeType === ELEMENT_NODE) {
      return element(node, options);
    }
    if (nodeType === DOCUMENT_NODE || nodeType === DOCUMENT_FRAGMENT_NODE) {
      return root(node, options);
    }
    if (nodeType === TEXT_NODE) {
      return text(node);
    }
    return null;
  };
  const element = (node, options) => {
    const isHtml = node.namespaceURI === HTML_NAMESPACE;
    const tagName = isHtml ? node.tagName.toLowerCase() : node.tagName;
    const attributes = getAttributeNames(node);
    const Component = options.components ? options.components[tagName] || tagName : tagName;
    const props = {};
    attributes.forEach((attr) => {
      const value = node.getAttribute(attr) || "";
      if (attr === "style") {
        props[attr] = parseStyle(value);
      } else {
        const property = domPropertyRecord[attr] || attr;
        props[property] = isHtml && property !== "list" && property in node && typeof node[property] !== "string" ? node[property] : value;
      }
    });
    if (!isHtml) {
      props.dangerouslySetInnerHTML = { __html: node.innerHTML };
      return options.createElement(Component, props);
    }
    return options.createElement(
      Component,
      props,
      ...children(node.childNodes, options)
    );
  };
  const root = (node, options) => options.createElement(
    options.Fragment,
    null,
    ...children(node.childNodes, options)
  );
  const text = (node) => node.data;
  const children = (children2, options) => map.call(children2, (child) => transform(child, options)).filter(Boolean);
  const getAttributeNames = (node) => {
    if (node.getAttributeNames == void 0) {
      return map.call(node.attributes, (attr) => attr.name);
    }
    return node.getAttributeNames();
  };

  function DOMParserReact(props) {
    const Fragment = props.Fragment || react.Fragment;
    const element = react.useMemo(() => parse(props.source, {
      createElement: props.createElement || react.createElement,
      Fragment,
      components: props.components
    }), props.deps || [props.source]);
    return typeof element === "string" ? /* @__PURE__ */ react.createElement(Fragment, null, element) : element;
  }

  exports.default = DOMParserReact;
  exports.parse = parse;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}, React);
